# chapter 21 : 빌트인 객체

## 자바스크립트 객체의 분류
- 표준 빌트인 객체 : ECMAScript 사양에 정의된 객체로 애플리케이션 전역 공통 기능 제공. 별도의 선언 없이 전역 변수처럼 언제나 참조 가능
- 호스트 객체 : ECAMSCript에는 없지만 자바스크립트 실행 환경(브라우저 or Node.js) 환경에서 추가로 제공되는 객체.
    - 브라우저 환경시 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker... 같은 Web API를 호스트 객체로 제공
    - Node.js 환경에서는 Node.js 고유 API를 호스트 객체로 제공
- 사용자 정의 객체 : 사용자가 직접 정의한 객체

## 표준 빌트인 객체
- Ojbect, String, Number, Boolean, Symbol, RegExp... 등 40 여 개의 표준 빌트인 객체 제공  
- Math. Reflect, JSON 제외 표준 빌틍린 객체는 모두 인스턴스 생성할 수 있는 생성자 함수 객체  
- 표준 빌트인 객체 생성 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype. Strign 인스턴스 프로토타입은 String.prototype.

## 원시값과 래퍼 객체
원시값을 객체처럼 사용하면 js 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.  
래퍼 객체(wrapper object) : 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체  
String 래퍼 객체 생성시 래퍼 객체의 [[StringData]] 내부 슬롯에 할당 후 처리 끝나면 다시 받아옴(숫자면 [[NumberData]])    
문자열, 숫자, 불리언, 심벌 이외의 원시값, 즉 null과 undefined는 래퍼 객체 생성 x

## 전역 객체
- global object는 코드 실행 전 js 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체  
- 어떤 객체에도 속하지 않은 최상위 객체
- 브라우저 에서는 window, Node.js에서는 global
- 프로토 타입 상 최상위 객체라는 의미는 아님
- 계층적 구조상 표준 빌트인 객체를 프로퍼티로 소유한다는 것을 말함.

### 전역 객체의 특징
- 개발자가 의도적 생성 불가. 생성자 함수 제공 x
- 전역 객체 프로퍼티 참조 시 window(또는 global) 생략 가능
- Object, String, Math, Promise 등 모든 표준 빌트인 객체를 프로퍼티로 가지고 있음
- var 키워드 선언 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 됨.
ex)
```js
var foo = 1;
console.log(window.foo) // 1

bar = 2;
console.log(window.bar); //2

function baz() {return 3; }
console.log(window.baz()); //3
```
- let, const 는 보이지 않는 개념적 블록(전역 렉시컬 환경의 선언적 환경 레코드)내에 존재
- 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유

### 빌트인 전역 프로퍼티
#### InFinity
무한대 나타내는 숫자값 Infinity

#### NaN
Not-a-Number를 나타내는 숫자값 NaN을 갖는 프로퍼티. Number.NaN 프로퍼티와 같다.

#### undefined
원시 타입 undefined를 값으로 갖음

### 빌트인 전역 함수
애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드

#### eval
eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 전달 받음.   
- 전달 받은 문자열 코드가 표현식이라면 eval 함수는 문자열 코드를 런타임에 평가하여 값 생성
- 표현식이 아닌 문이라면 eval 함수는 문자열 코드를 런타임에 실행
- 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문 실행
- eval 함수는 기존의 스코프를 런타임에 동적으로 수정
- eval 함수에 전달된 코드는 이미 그 위치에 존재하던 코드처럼 동작 
- strict mode에선 기존 스코프 수정하지 않고 eval 함수 자신의 자체적인 스코프 생성  
**eval 함수는 js엔진에 의한 최적화 수행 x 보안에도 취약함. 따라서 사용 금지해야 한다.**

#### isFinite
- 유한수이면 true, 무한수이면 false. NaN 역시 false
- isFinite(null)은 true-> null 숫자 변환시 0이 되기 때문에

#### isNaN
- NaN인지 검사하여 true, false 
- 인수의 타입이 숫자가 아닌 경우 숫자로 바꿔서 검사 수행

#### parseFloat
문자열 인수를 부동 소수점 숫자, 실수로 해석하여 반환
- 문자열을 실수로 해석하여 반환
- 공백 구분시 첫 번째 문자열만 반환
- 첫 번째 문자열 숫자 변환 x시 NaN 반환
- 앞뒤 공백은 무시

#### parseInt
- 전달받은 문자열 인수를 정수로 해석하여 반환
- 문자열이 아니면 문자열로 변환 후 정수로 해석하여 반환
- 두 번째 인수로 진법을 나타내는 기수(2~36) 전달 가능
- 첫번째 인수 문자열이 "0x", "0X"로 시작하는 16진수 리터럴 시 16진수로 해석하여 10진수 정수로 반환
- 2진수, 8진수 리터럴은 제대로 해석 못함
- 첫 번째 인수 전달 문자열의 첫 번째 문자가 해당 지수 숫자 변환 x 시 NaN 반환
- 두 번째 문자부터 해당 진수가 아니라면 해석한 부분까지의 정수값만 반환
- 공백있으면 첫 번째 문자열만 해석. 해석 불가 시 NaN 반환

#### encodeURI / decodeURI
- encodeURI 함수는 완전한 URI 문자열로 전달받아 이스케이프 처리를 위해 인코딩함.
- 이스케이프 처리란 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것
- URI 문법에 따르면 URL은 아스키 문자 셋으로만 구성되어야 함.
- decodeURI 함수는 이스케이프 처리 이전으로 디코딩함

#### encodeURIComponent / decodeURIComponent
위와 차이는 =, ?, & 까지 인코딩 (URI 구성요소인 쿼리 스트링의 일부로 간주)하냐 안하냐의 차이

### 암묵적 전역
- 선언하지 않은 식별자에 값 할당 시 젼역 객체의 프로퍼티가 됨
- 이를 암묵적 전역이라 함
- 전역 객체의 프로퍼티로 추가된 것이므로 변수 호이스팅 x
- 프로퍼티 이므로 delete 연산자로 삭제 가능


## Questions
- 래퍼 객체를 생성하는 타입에 대해 말해보세요.

